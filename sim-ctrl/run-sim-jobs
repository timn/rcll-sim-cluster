#!/usr/bin/env python3

from work_queue import WorkQueue
from pod_controller import PodController
from config import Configuration

import os
import argparse
import time
import kubernetes
from datetime import datetime, timedelta
from traceback import print_exc
from kubernetes.client import V1DeleteOptions

class SimController(object):
	def __init__(self, include_recently_failed=False, job_namespace=None):
		self.config	= Configuration()
		self.include_recently_failed = include_recently_failed
		self.namespace = self.config.kube_namespace
		self.job_namespace = job_namespace or self.config.kube_namespace
		if self.job_namespace == "auto":
			name_prefix = "rcll-sim-"
			if "JOB_NAMESPACE_PREFIX" in os.environ:
				name_prefix = os.environ["JOB_NAMESPACE_PREFIX"]
			self.job_namespace = self.generate_namespace_name(name_prefix)

		# The work queue will figure out a valid combination of MongoDB access
		# parameters, e.g., host/port, URI, or replica set discovery via DNS
		self.wq = WorkQueue(host=self.config.mongodb_host,
		                    port=self.config.mongodb_port,
		                    uri=self.config.mongodb_uri,
		                    srv_name=self.config.mongodb_rs_srv,
		                    database=self.config.mongodb_queue_db,
		                    replicaset=self.config.mongodb_rs,
		                    collection=self.config.mongodb_queue_col)

		self.podctrl = PodController(self.config)

	def __enter__(self):
		if self.job_namespace != "default":
			self.create_namespace()
		self.initialized = True
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		if self.job_namespace != "default":
			self.delete_namespace()
		self.initialized = False

	def generate_namespace_name(self, name_prefix):
		kube_config = kubernetes.config.load_incluster_config()
		core_api = kubernetes.client.CoreV1Api()
		batch_api = kubernetes.client.BatchV1Api()

		pod_name  = os.environ["POD_NAME"]

		pod = core_api.read_namespaced_pod(pod_name, self.namespace)
		job_name = pod.metadata.labels["job-name"]
		job = batch_api.read_namespaced_job(job_name, self.namespace)

		parallelism = job.spec.parallelism
		label_selector_dict = dict(job.spec.selector.match_labels)
		label_selector_str = ",".join(["%s=%s" % (key,value) for (key,value) in label_selector_dict.items()])
		field_selector_str="status.phase=Running"

		num_tries = 0
		pods=[]
		while num_tries < 30:
			all_pods = core_api.list_namespaced_pod(self.namespace,
			                                        label_selector=label_selector_str,
			                                        field_selector=field_selector_str)
			pods = list(map(lambda p: p.metadata.name, all_pods.items))
			if len(pods) == parallelism:
				break
			else:
				num_tries += 1
				time.sleep(1)

		pods.sort()

		if len(pods) == parallelism:
			index = pods.index(pod_name)
			return "%s%d" % (name_prefix, index)
		else:
			raise Exception("Failed to determine pod index")

	def create_namespace(self):
		print("Creating namespace '%s'" % self.job_namespace)
		kube_config = kubernetes.config.load_incluster_config()
		core_api = kubernetes.client.CoreV1Api()
		manifest = {"kind": "Namespace", "apiVersion": "v1", "metadata": { "name": self.job_namespace } }
		core_api.create_namespace(manifest)
		if "JOB_NAMESPACE_COPY_SECRETS" in os.environ:
			secrets = os.environ["JOB_NAMESPACE_COPY_SECRETS"].split(' ')
			for s in secrets:
				print("  - copying secret '%s' from '%s'" % (s, self.namespace))
				self.copy_secret(s, self.namespace, self.job_namespace)

	def delete_namespace(self):
		print("Deleting namespace '%s'" % self.job_namespace)
		kube_config = kubernetes.config.load_incluster_config()
		core_api = kubernetes.client.CoreV1Api()
		try:
			core_api.delete_namespace(name=self.job_namespace, body = V1DeleteOptions())
		except:
			pass

	def copy_secret(self, name, from_namespace, to_namespace):
		kube_config = kubernetes.config.load_incluster_config()
		core_api = kubernetes.client.CoreV1Api()
		secret = core_api.read_namespaced_secret(name, from_namespace)
		manifest = {
			"kind": "Secret",
			"apiVersion": "v1",
			"metadata": { "name": name },
			"data": dict(secret.data)
		}
		core_api.create_namespaced_secret(to_namespace, manifest)

		
	def run(self):
		if not self.initialized:
			raise Exception("Must use 'with' statement to use instance")

		recently_failed_deadline=None
		if not self.include_recently_failed:
			recently_failed_deadline = datetime.utcnow() - timedelta(minutes=15)
		job = self.wq.get_next_item(recently_failed_deadline)
		while job is not None:
			# We do +1 here to include the one we are currently handling
			(all_pending, without_recently_failed) = self.wq.num_pending_jobs(recently_failed_deadline)
			print("Open jobs: %d (additional recently failed: %d)" % (without_recently_failed+1, (all_pending-without_recently_failed)))

			try:
				print("Running job %s in namespace %s" % (job["name"], self.job_namespace))
				start_time = datetime.now()
				manifests=[]
				num_items = { "YAML": 0, "Pod": 0, "Container": 0, "Service": 0, "Ingress": 0, "ConfigMap": 0 }
				for i in job["params"]["template_parameters"]:
					i["vars"]["namespace"] = self.job_namespace
					i["vars"]["job_name"] = job["name"]
					print("  - template: %s" % i["template"])
					sufficient_containers = i["sufficient_containers"] if "sufficient_containers" in i else []
					items = self.podctrl.create_from_template(i["template"], i["vars"],
					                                          sufficient_containers=sufficient_containers)
					for i in items:
						#print("    - %s: %s" % (i[0], i[1]))
						num_items[i[0]] += 1
						if i[0] == "Pod":
							num_items["Container"] += len(i[2]["spec"]["containers"])
						manifests.append(str(i[2]))

				update = { "$set": { "manifests": manifests } }
				self.wq.update_item(job["name"], update)

				format_string="Running {Pod} pods, {Container} cont, {Service} svc, " \
				               + "{Ingress} ing, {ConfigMap} cm"
				print(format_string.format(**num_items))

				print("Monitoring pods")
				if self.podctrl.monitor_pods():
					print("Job %s completed successfully" % job["name"])
					self.wq.mark_item_done(job["name"])
				else:
					print("Job %s failed, reqeueing" % job["name"])
					self.wq.requeue_item(job["name"])
			except:
				print("*** EXCEPTION ***")
				print_exc()
				print("Job %s failed, reqeueing" % job["name"])
				self.wq.requeue_item(job["name"])

			# Cleanup removing pods, services
			self.podctrl.delete_all()
			end_time = datetime.now()
			print("Job %s finished (took %s)\n" % (job["name"], str(end_time-start_time)))

			if not self.include_recently_failed:
				recently_failed_deadline = datetime.utcnow() - timedelta(minutes=15)
			job = self.wq.get_next_item(recently_failed_deadline)
		print("No more open jobs")

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Run RCLL Cluster Sim Jobs')
	parser.add_argument('--include-recently-failed', action='store_true',
	                    help='Allow execution of recently failed jobs.')
	parser.add_argument('--namespace',
	                    help='Namespace for created pods.')
	args = parser.parse_args()

	with SimController(args.include_recently_failed, args.namespace) as sim_ctrl:
		sim_ctrl.run()
